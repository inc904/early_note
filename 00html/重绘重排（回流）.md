## HTML页面进行重绘和重排（回流）

### 浏览器的运行机制：

1. 构建DOM树（parse）：渲染引擎解析HTML文档，首先按将标签转换成DOM树种的 DOM Node（包括 js 生成的标签）**生成内容树**（content tree / DOM tree）。
2. 构建渲染树（construct）：解析对应的CSS样式文件信息（包括js 生成的样式和外部css文件），而这些文件信息以及HTML种可见的额指令（如<b></b>），**构建渲染树**（Rendering Tree/Frame Tree）。render tree 中每个Node都有自己的style，而且 render tree 不包含隐藏的节点，因为这些节点不会用于呈现。
3. 布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小位置等，给出每个节点所应该在屏幕出现的精准坐标。
4. 绘制渲染树（paint/repaint）：便利渲染树，使用 UI 层来绘制每个节点。

### 重绘（repaint/redraw）：

 		当盒子的位置、大小以及其他属性，例如颜色、字体大小都确定下来之后浏览器便把这些元素都按照各自的特性进行绘制一遍，将内容呈现到页面上。

​		重绘是指每一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

#### 触发重绘的条件：

​		改变元素外观属性，如：color，background-color等。

​		注意：table及其内部元素可能需要多次计算才能确定好其在渲染树种节点的属性，比同等元素要多花两倍时间，这就是我们尽量避免table布局的原因之一。

### 重排（重构/回流/reflow）：

当渲染树中一部分或全部**因为元素的规模尺寸、布局、隐藏等改变而需要重新构建，这就称为回流**，每个页面至少要经过一次回流，就是在页面第一次加载的时候。

### 重绘和重排的关系：

​		在重排的时候，浏览器会使渲染树中收到影响的部分失效，并重新构建这部分渲染树，完成回流后，浏览器会重新绘制收到影响的部分到页面中，该过程称为重绘。

​		所以重排必定会引发重绘，重绘不一定会引发重排。

#### 触发重排的条件

1. 页面渲染初始化（无法避免）
2. 添加或删除可见的DOM元素
3. 元素的位置改变、或者使用了动画
4. 元素的尺寸改变：大小、外边距、边距
5. 浏览器窗口的变化（resize事件的发生）
6. 填充内容的改变，比如文本的改变或图片大小改变而引起计算值宽度或高度的改变
7. 读取某些元素属性：offsetLeft/Top/Height/Width、clientTop/Width

### 重绘重排的代价

耗时，导致浏览器卡慢

### 优化

1. 浏览器自己的优化：浏览器会维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理，这样就会让多次的回流、重绘变成了一次。
2. 我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，即我们可以合并多次的DOM和样式的修改，并减少对style样式的请求。
   1. 直接改变元素的clsaaName
   2. 先设置 display：none，然后进行页面布局等操作，设置完成后将元素设置为 display： block，这样就只引发两次重绘重排。
   3. 使用cloneNode（true or false）和 replaceChlid 技术，引发一次回流和重绘。
   4. 将需要多次重排的元素，position：absolute/fixed。元素脱离了文档流，他的变化就不会影响到其他元素
   5. 如果需要创建多个DOM节点，可以使用DocumentFragment创建完成后一次性的加入 Documment

### 结合项目中使用