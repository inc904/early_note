## 父子组件传值

### 1、props+属性

```html
<!-- 调用父组件传递的数据 -->
<!-- 在子组件调用的时候，通过属性绑定的方式，将父组件的数据传递给子组件 -->
	<comp :parent-msg="msg"></comp>
<!-- 在接受的时候，数据名如果是使用的驼峰语法，那在组件引用的时候必须使用肉串语法 -->
```
```js
// 子组件 需要 使用 props 属性接受，父组件传来的数据
components: {
	comp: {
		data(){
			// data 上的数据，是属于子组件自己的，可读可写
			return {
				sonMsg: 'son-message'
			},
			// 接收 父组件传值，可读不可写
			props: ['parentMsg']
			template: `<h1> 
					子组件自己的数据：{{ sonMsg }}
					--->
					父组件传递的数据：{{ parentMsg }}
					</h1>`
		}
	}
}
````
### 2、组件上的 $parent+$children[i]

### 3、provide+inject

```js
// 父组件
export default{
    provide:{ // 提供值
        message: 'hello Vue!'
    }
}
// 子组件
{{ message }}
export default{
    inject:['message'] // 使用值
}
```

### 4、$attrs + $listeners

```js
// 多层组件 三级组件中 使用 $attrs
<Chlidred :name="name" :age="age"/>
<GrandChild v-bind="$attrs" />
/**
$attrs 相当于 子组件中接收到所有属性，直接传递给二级子组件
*/
```

### 5、ref  获取子组件节点，在父组件中通过属性的方式访问子组件上的属性

## 父子组件传递方法

```html
<!-- 调用父组件传递的方法 -->
<!-- 在子组件调用的时候，通过事件绑定的方式，将父组件的方法传递给子组件 -->
	<comp @parent-fn="show"></comp>
<!-- 在接受的时候，数据名如果是使用的驼峰语法，那在组件引用的时候必须使用肉串语法 -->
// 后来使用的时候，发现 命名和调用规则： 肉串-肉串  驼峰-驼峰
```
```js
// 父组件的方法
methos: {
	show(p1, p2){
		console.log('调用了父组件上的show方法')
	}
}
// 子组件 需要 使用 props 属性接受，父组件传来的数据
components: {
	comp: {
		data(){
			// data 上的数据，是属于子组件自己的，可读可写
			return {
				
			},
			// 接收 父组件传值，可读不可写
			props: ['parentMsg']
			template: `
			<input type="button" value="子组件按钮-调用自己的方法" @click="myclick">
			<input type="button" value="子组件按钮-调用父组件上的方法" @click="pclick">
			`,
			methos:{
				myclick(){
					console.log('子组件自己的方法')
				}
				pclick(){
					// 接收方法的时候，命名全都采用肉串语法，或者全部小写，不要 肉串和驼峰 混用
					this.$emit('parent-fn', p1, p2) // 函数名后面，都是需要传入的参数
				}
			}
		}
	}
}
````

